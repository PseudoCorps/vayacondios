h1. brocephalus

Brocephalus is a fabric for routing metrics and facts through your organization.

Simple enough to use in a shell script, performant enough to use everywhere, reliable and powerful enough that why the hell *wouldn't* you bro.send() that?

* *Metrics*: Any system anywhere can throw a namespaced, timestamped numeric quantity at Brocephalus. These metrics can report on status ('there are 3 cups of coffee remaining'), timing ('this response took 100ms'), or counting ('I just served a 404 response code').

* *Facts*: Any system anywhere can throw an arbitrary namespaced, timestamped JSON hash at Brocephalus. (We call this 'facts' in contrast to 'logging' to emphasize that this is _structured_ data with _unstructured_ semantics).

h3. Design goals

* *Decentralized*:      Any system anywhere can dispatch facts or metrics using an arbitrary namespace and schema. Nothing needs to be created in advance.
* *Bulletproof*:        Clients will never fail because of network loss or timeout.
* *Fast*:               UDP clients are non-blocking and happily dispatch thousands of requests per second.
* *High Throughput*:    Brocephalus on a t1.micro should outpace Graphite on an m1.small and Mongo on an m1.large.
* *Minimal Dependency*: Ruby clients can dispatch or query using nothing outside of the standard libraries. 
* *Ubiquitous*:         A shell script can send a simple basket of facts in < 3 lines.

Not design goals:

* *Reliable delivery*:  If the network or datastore fails, Brocephalus will drop packets on the floor. However, it will report metrics to show this is happening.
* *Storage*:            Brocephalus is designed to be friends with Graphite and MongoDB (and pluggable for others). It doesn't do anything but aggregation and routing, though.
* *Analysis*:           ditto.
* *Graphing*:           ditto.


h2. Clients


* Periodic fetch        Chef
* Periodic fetch        Fog (cloud machines)
* Periodic fetch        google analytics
* hadoop script completed, sends { script_name started_at run_time completion_status run_params cluster_config }
* simple dashboard form
* notify        cluster appears
* I am A foo-bar, assign me uniquely the NEXT foo-bar
* get 

h2. API

* path components must be UTF-8 character strings that contain only ASCII letters, numbers, _, or -.

* Brocephalus reserves the right to read and write paths in /bro, and the details of those paths will be documented; it will never read or write other paths unless explicitly asked to.

* tree_merge rules:

  - hsh1 + hsh2  = hsh1.merge(hsh2)
  - arr1 + arr2  = arr1 + arr2
  - val1 + val2  = val2
  
  - hsh1 + nil   = hsh1
  - arr1 + nil   = arr1
  - val1 + nil   = val1
  
  - nil  + hsh2  = hsh2
  - nil  + arr2  = arr2
  - nil  + val2  = val2

  - otherwise, exception

  types: Hash, Array, String, Time, Integer, Float, Nil

h4. add (set? send?)

GET  http://brocephalus:9099/f/{clxn}/{arbitrary/name/space}.{ext}?auth=token&query=predicate

  db.collection(collection).save


*   
  

get 

  
h4. get

POST http://brocephalus:9099/f/arbitrary/name/space  with JSON body


h4. increment

h4. add to set

what do we need to provide the 'I got next' feature of old_broham?

h2. Others

GET latest
GET all
GET next

h4. Doozerd

"Doozerd":https://github.com/ha/doozerd 

* DEL path, rev
* GET path, rev => value, rev
* SET path, rev, value => rev
* WAIT path, rev => path, rev, value, flags
* WALK path, rev, offset => path, rev, value
* REV => rev

* WATCH 
* globbing on path sequences. doozerd allows ?, * and **.

h4. Noah

"Noah":https://github.com/lusis/Noah has a few basic design goals:

The system MUST support RESTful interaction for operations where REST maps properly
The system MUST support basic concepts of hosts, services, applications and configurations
The system MUST support horizontal scaling.

Additionally:

The system SHOULD be flexible in deployment options.
The system SHOULD support watches similar to ZooKeeper
The system SHOULD support pluggable callbacks for watches.
The system SHOULD support being a client of itself.

h3. Zookeeper

* "Zookeeper":http://zookeeper.apache.org/

h3. Chubby

* "Chubby":http://labs.google.com/papers/chubby.html



h2. Design

h3. Network layer

Brocephalus accepts input via:

* UDP  -- UDP is connectionless, so it's fire-and-forget. As Etsy puts it,

  bq. So, why do we use UDP to send data to StatsD? Well, it’s fast — you don’t want to slow your application down in order to track its performance — but also sending a UDP packet is fire-and-forget. Either StatsD gets the data, or it doesn’t. The application doesn’t care if StatsD is up, down, or on fire; it simply trusts that things will work. If they don’t, our stats go a bit wonky, but the site stays up. Because we also worship at the Church of Uptime, this is quite alright. (The Church of Graphs makes sure we graph UDP packet receipt failures though, which the kernel usefully provides.)

  However, UDP (though bone-simple) is somewhat arcane; and since the packet size of a UDP datagram is limited, Brocephalus can't accept large Facts via UDP.
  
* HTTP -- HTTP is ubiquitous, and allows for security, load-balancing and so forth. It's connectionful (which is good and bad) and it's heavier-weight enough that you'll want to stick with UDP at the thousands-per-second case.

h3. Aggregator / Router

* HTTP via Goliath
* also opens a UDP socket
* is drop-in compatible with statsd
* "Ruby Metrics":https://github.com/johnewart/ruby-metrics for accumulation
  - ATTN: does this allow for namespacing?

* drops packets but doesn't fail if Graphite is missing
* drops packets but doesn't fail if MongoDB is missing


h3. Watches

zeromq pubsub?
pubsubhubbub?

h3. Statsd

* PUT /_stats/meter?name={name.of.stat}&incr={num}
* PUT /_stats/counter?name={name.of.stat}&incr={num}
* GET /_stats/instrument?name.of.stat=value




h3. Components

h4. client libraries:

<pre>
                        UDP	HTTP    facts   metrics 
  ruby eventmachine     y       y       y       y       
  ruby stdlib-only      y                       y       
  ruby faraday          n       y       y       y       
  java                    ?     y       y       y       
  curl (shell)          n       y       y       y       
</pre>

h4. backend targets:

* Graphite
* MongoDB

h4. integrations

Integrations can
* send to a
* store some limited

* goliath: statsd_middleware and statsd_plugin. 
* ATTN: rack:  ???
* ATTN: rails: ???

QUESTIONS: 
* ATTN: do we have to worry about memory use?
* ATTN: idempotency
* ATTN: make it easy to include, or ignore:
  - machine info
  - deploy info


h2. Notes

h3. When to use HTTP vs UDP

h4. HTTP is Connectionful

HTTP is connectionful:
* you get acknowledgement that a metric was recorded (this is good).
* if the network is down, your code will break (this is bad). (Well, usually. For some accounting and auditing metrics one might rather serve nothing at all than something unrecorded. Brocephalus doesn't address this use case.)

h4. UDP has Packet Size limitations

If you're using UDP for facts, you need to be *very* careful about payload size.

From the "EventMachine docs":http://eventmachine.rubyforge.org/EventMachine/Connection.html#M000298
bq.  You may not send an arbitrarily-large data packet because your operating system will enforce a platform-specific limit on the size of the outbound packet. (Your kernel will respond in a platform-specific way if you send an overlarge packet: some will send a truncated packet, some will complain, and some will silently drop your request). On LANs, it’s usually OK to send datagrams up to about 4000 bytes in length, but to be really safe, send messages smaller than the Ethernet-packet size (typically about 1400 bytes). Some very restrictive WANs will either drop or truncate packets larger than about 500 bytes.

h2. Colophon

h3. Contributing to brocephalus
 
* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet
* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it
* Fork the project
* Start a feature/bugfix branch
* Commit and push until you are happy with your contribution
* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

h3. Copyright

Copyright (c) 2011 Infochimps. See LICENSE.txt for further details.
